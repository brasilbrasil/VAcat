#' Generate the likelihood profile for a node's margins
#'
#' Given a model and a sample of data from that model, calculate the
#' log-likelihood for all possible combinations of marginal probabilities
#' for a node.
#' @param d a \code{\link{catNetwork}} model object
#' @param nname the numeric node for a model OR a character name for the node
#' @param data a dataframe of sample data for the model, in either character
#' names of levels or numbers for the category level of each node
#' @note "All possible combinations" is an exageration, it's actually limited
#' to the range 0.1 - 0.9 in increments of 0.1 as generated by generate.margins().
#' @return a dataframe with the columns for the marginal probabilities for each
#' possible value of the node, and a column for the log-likelihood for those
#' margins given the data.
#' @export
margin.loglik <- function(d, nname, data) {
    nodes <- d@nodes
    numnodes <- d@numnodes
    if (is.character(nname)) {
        n <- which(nodes %in% nname)
        if (length(n) != 1)
            stop("nname not found in nodes, or found more than once.")
    } else {
        n <- floor(nname)
        if (n < 1 | n > numnodes)
            stop("nname outide the range of nodes in the model.")
    }
    categories <- d@categories[[n]]
    newmarge <- generate.margins(length(categories))
    attr(newmarge, "out.attrs") <- NULL  #remove some expand.grid cruft
    ## a dataframe to store results
    output <- as.data.frame(newmarge)
    names(output) <- categories
    output$loglik <- as.numeric(NA)
    ## iterate over all combinations
    for (i in 1:nrow(newmarge)) {
        ## nead to clean some attributes from this vector so
        ## cnNodeLoglike doesn't complain
        p <- NULL
        for (j in 1:ncol(newmarge)) {
            p <- c(p, newmarge[i, j])
        }
        foo <- fix.marginals(d, n, p)
        output$loglik[i] <- cnNodeLoglik(foo, n, data)
    }
    return(output)
}

#' Fix the marginal probabilities of a node
#'
#' Set the marginal probabilities of a node in the model by adjusting
#' the underlying conditional probabilities in the catNetwork object.
#' @param d a \code{\link{catNetwork}} model object
#' @param n the number of the node to modify
#' @param p the desired new marginal probabilities. It must be a numeric
#' vector with values between 0 and 1, summing to 1, with as many elements
#' as there are category levels of node n.
#' @return a \code{\link{catNetwork}} model object identical to d, except the marginal
#' probabilities of node n have been altered.
#' @export
fix.marginals <- function(d, n, p) {
    if (sum(p) != 1)
        stop("Desired marginal probabilities must sum to 1.")
    current <- cnNodeMarginalProb(d, n)
    if (length(current) != length(p))
        stop("Mismatch in desired probabilty and actual number of nodes.")
    ## vector to multiply each element of the conditional probability
    ## list so the new marginal probabilty is equal to p
    m <- p / current
    ## get the (possibly recursive) list of conditional probabilities
    l <- d@probabilities[[n]]
    ## multiply by the vector of new proportions
###normult <- function(x) {
###    ## scale and normalize the conditional probabilities
###    return(x * m / sum(x * m))
###}
###k <- rapply(l, normult, classes="numeric", how="replace")
    k <- rapply(l, function(x) x*m, classes="numeric", how="replace")
    d@probabilities[[n]] <- k
    return(d)
}

#' Generate a range of marginal probabilities
#'
#' Generate a dataframe with a varying number of columns. Values are
#' constrained to range from 0.1 to 0.9 in increments of 0.1, and row
#' totals must sum to 1
#' @param n the number of columns to generate. Defaults to 2.
#' @return a dataframe with n columns
#' @export
generate.margins <- function(n=2) {
    if (n > 10)
        stop("generate.margins is too coarse for more than 10 categories.")
    foo <- NULL
    for (i in 1:n) {
        foo[[i]] <- seq(0.1, 0.9, by=0.10)
    }
    bar <- expand.grid(foo)
    bar <- bar[apply(bar, 1, sum) == 1, ]
    return(bar)
}
